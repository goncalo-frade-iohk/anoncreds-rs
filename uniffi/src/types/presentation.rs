use std::collections::HashMap;
use std::sync::Arc;
use anoncreds_core::types::Presentation as AnoncredsPresentation;
use anoncreds_core::types::PresentationRequest as AnoncredsPresentationRequest;

use crate::{AnoncredsError, Nonce};
use crate::custom_types::{AttributeInfoValue, PredicateInfoValue};

pub struct Presentation {
    pub core: AnoncredsPresentation,
}

impl Presentation {
    pub fn new(json_string: String) -> Result<Self, AnoncredsError> {
        let core_def: AnoncredsPresentation = serde_json::from_str(&json_string)
            .map_err(|err| AnoncredsError::ConversionError(err.to_string()))?;
        return Ok(Presentation { core: core_def });
    }

    pub fn get_json(&self) -> Result<String, AnoncredsError> {
        serde_json::to_string(&self.core).map_err(|err| AnoncredsError::ConversionError(err.to_string()))
    }
}

pub struct PresentationRequest {
    pub core: AnoncredsPresentationRequest,
}

impl PresentationRequest {
    pub fn new(json_string: String) -> Result<Self, AnoncredsError> {
        let core_def: AnoncredsPresentationRequest =
            serde_json::from_str(&json_string).map_err(|err| AnoncredsError::ConversionError(err.to_string()))?;
        return Ok(PresentationRequest { core: core_def });
    }

    pub fn get_json(&self) -> Result<String, AnoncredsError> {
        return serde_json::to_string(&self.core).map_err(|err| AnoncredsError::ConversionError(err.to_string()))
    }

    pub fn get_requested_attributes(&self) -> HashMap<String, Arc<AttributeInfoValue>> {
        let core_value = self.core.value().requested_attributes.clone();
        let mut returned_value = HashMap::new();
        core_value.iter().for_each(|attribute| {
            returned_value.insert(
                attribute.0.to_string(),
                Arc::new(AttributeInfoValue::from(attribute.1))
            );
        });
        return returned_value
    }

    pub fn get_requested_predicates(&self) -> HashMap<String, Arc<PredicateInfoValue>> {
        let core_value = self.core.value().requested_predicates.clone();
        let mut returned_value = HashMap::new();
        core_value.iter().for_each(|attribute| {
            returned_value.insert(
                attribute.0.to_string(),
                Arc::new(PredicateInfoValue::from(attribute.1))
            );
        });
        return returned_value
    }

    pub fn get_name(&self) -> String {
        return self.core.value().name.clone()
    }

    pub fn get_version(&self) -> String {
        return self.core.value().version.clone()
    }

    pub fn get_nonce(&self) -> Arc<Nonce> {
        let nonce = self.core.value().nonce.try_clone().unwrap();
        return Arc::new(Nonce::from(nonce));
    }
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;
    use serde_json::ser::Compound::Map;
    use anoncreds_core::data_types::issuer_id::IssuerId;
    use anoncreds_core::data_types::schema::{Schema, SchemaId};
    use anoncreds_core::types::AttributeNames;
    use crate::{Credential, CredentialDefinition, CredentialRequests, LinkSecret, presentation, PresentationRequest, Prover, RequestedAttribute, RequestedPredicate};

    #[test]
    fn test_get_requested_attributes() {
        let json_data = r#"
        {
            "requested_attributes":{
            "attribute_1":{
            "name":"name",
            "restrictions":[

            ]
            }
            },
            "requested_predicates":{

            },
            "name":"presentation_request_1",
            "nonce":"1177620373658433495312997",
            "version":"0.1"
        }
        "#;
        let presentationRequest = PresentationRequest::new(json_data.to_string()).unwrap();
        println!("{:?}", presentationRequest.get_requested_attributes());
        let requested_attributes = presentationRequest.get_requested_attributes();
        requested_attributes.iter().for_each(|attribute| {
            assert_eq!(attribute.0, "attribute_1");
            assert_eq!(attribute.1.core.name.to_owned().unwrap(), "name");
        });
    }

    #[test]
    fn test_get_requested_predicates() {
        let json_data = r#"
        {
            "requested_attributes":{
            "attribute_1":{
            "name":"name",
            "restrictions":[

            ]
            }
            },
            "requested_predicates":{

            },
            "name":"presentation_request_1",
            "nonce":"1177620373658433495312997",
            "version":"0.1"
        }
        "#;
        let presentationRequest = PresentationRequest::new(json_data.to_string()).unwrap();
        println!("{:?}", presentationRequest.get_requested_predicates());
        let requested_predicates = presentationRequest.get_requested_predicates();
        assert!(requested_predicates.is_empty())
    }

    #[test]
    fn test_create_presentation() {
        let request_json = r#"
        {
            "requested_attributes":{
            "attribute_1":{
            "name":"name",
            "restrictions":[

            ]
            }
            },
            "requested_predicates":{

            },
            "name":"presentation_request_1",
            "nonce":"1177620373658433495312997",
            "version":"0.1"
        }
        "#;
        let credential_json = r#"
{"schema_id":"http://host.docker.internal:8000/prism-agent/schema-registry/schemas/39a47736-2ecc-3250-8e3c-588c154bb927","cred_def_id":"http://192.168.68.103:8000/prism-agent/credential-definition-registry/definitions/917accdd-ec8d-3da0-a318-e46546af9ea0/definition","rev_reg_id":null,"values":{"name":{"raw":"Anoncred","encoded":"27130890757551782413264165741454596397833173331911630508288551269957836972686"},"surname":{"raw":"Test","encoded":"37624419805439260122109877671597282370833625459492083204494327308667894128165"}},"signature":{"p_credential":{"m_2":"102109003390886746773497278461632372473791039112918848318466342424730326741372","a":"42116044194878773806273110502949817332934447929317205923466773628489710779138899680097328820293983937430707154984580781119571681203335543270394287135937813121547521930283320613902693913588990335413224187290160857906716222991812485687649834024249544039945222354651021516150269447380286327263737939246818194265861669742105877581001498445219152904256205244134455465758034137071511678926975919155955270630980486972960330422451716491552346030105989103208529777378352839924044631787723401729024049732897457093134226620067871065343025348677449456062274630008919485803732322923216853114762485507120395427374658167818664317982","e":"259344723055062059907025491480697571938277889515152306249728583105665800713306759149981690559193987143012367913206299323899696942213235956742930176173237021981512346508197513993519","v":"8958936057601157390439604219267950104673264175516514638834334773079160613292892720468705317605688514990488671921395161476446949408450600148228186965386248597903013070923138667810996558950362688537884405361566568712843358400941487168579636469629185656342812159018640439596595247195118378910210158416964665590902204289872252473655159662268931938613644561190868130434556236640518515968710900897837876426637636586539118289732328836399813433507698121308870405844223858507993552639599842875233743404299146557773495479414919780803081294979467141872946454634516063747388542075584256605641250416985797655524141642365252167460103043962900308658609418157396977255468306424050353662093213652128349136649724659746407764630714607412671044174633318942879541296285698342302387444521283467373090807437629457311797213351742170746254497694"},"r_credential":null},"signature_correctness_proof":{"se":"25944873395612327392351415441127360872699927933421586589316114370400982407957105975966039372863653555538174968754148082796339609090210319071734977319346165386474060132532800242759124921177288655478820630038133227753029544310981333022028421565563278239479534682312193186207051304873521911515676823511213045589634118602893805540950710632103318072964537894631222273515065553050424813712122299323164591318037241549594147017033384798717594742836945803083045078757171680298278674551910146551108512732255647170532673692367741323256360274120912991853325757232265796552222670835418830387937238390104677636248792089022034614228","c":"102094796736531238552170265445471860249532892684261556052466195739075428796053"},"rev_reg":null,"witness":null}
        "#;

        let credential_definition_json = r#"
        {"schemaId":"http://host.docker.internal:8000/prism-agent/schema-registry/schemas/39a47736-2ecc-3250-8e3c-588c154bb927","type":"CL","tag":"licence","value":{"primary":{"n":"118960980235053678285866158194481394701966319284464068420577423025442894291351470746417220891892801448901119848610256072872913227322933367799598066827543858615736185962808106551161050641922881593653376378859434885431911864332405423533438273229871065600907971662781924543408580315819587823243564476605512533520861051171862120862700048583168180876448306178720912571311683163109350083557322938451140300475025816769544925942570062456102189593076023541483322919980804593772188766657973171383333018569207123132742829141789449664650725464468461326243049830988446264983363641988432473839803071469702587945263371694701779236749","s":"45535735834221829601835278289078513234986702595434415069835587396887201880301873649743071377338722082294653853419745761560547696812714896069277666944121456170656883098157148026364526516055862925018776699368173754797760858992667902908135088444670050158468599626043877674873544478441060484267541524259710287438779045779756958374439893880138363537812651624361755155004482472270630465110091497210672767190300625643031480661219121273135368542628352751272605492921340157660082281958466802738672194592925509198027123335500200981633662197369894729535021402962097657100318433451508690304278491689118949576832586235115598947538","r":{"name":"18971466105336597631684124098904811616808831059892312124955810957543519299302482055022886255410520986338425484880129810219397785756499788457162985043173952243326240059732859467094491261854507666083907516696220827534156872621688655077789089845336178317294076320852232842401477117473604188463581786854384879029350271659257952500863503198256190074832075787456594202501906228675398161902286812138584561408783393585528078284169503267654849701371109487671734310430052670049614554159745378533706646629858654943995607516439498734608656204071148090251272264315853528480754123968509892143987103991787853023953026588286953177951","master_secret":"48775879612460458467206755106206914935025084869788890995132258163153008561133649557456683009531824810243470861197984538425057701086620417066735273018755198735380852052570417246878168630473514300910293337098357508859935499564325035162108864288855306843339585076320579313377505596064804415101429339767954048220229601067031757533900677242008847068129036997851384674241908701412960558635444251652187724878750359472306759711450355039927236722393051879414698825935423806648268846892014550330353553550345257286498065996835511880716646388832277903641317487893065710724238554134213121570224126117396100105378140099297603104048","surname":"116104995258592119437028593026680777585820123639773885244056048933497484398315490678048098422807062697052106135872996828269085785463806249493177254618165845856834716426728737462482279265844063412758859462743167316087225254498442518239523079500830272127714193055338494551586967411459481311970025406449125758185268287032183798967493631166282394899846678092985175161320285604497321783716621871571807145393664758995284941457630744662768126200349799442624624889092491077010704977393143653755494535372289482593980132910736454534829254859491445427735902733493897526332995599440295373530731818050421686059148474351876830757716"},"rctxt":"14758001115139514002260209593755240346559937695997944102573778697858174338707579280201140728970067445595136867847114800356832681048071498117239668667154429457845308987681296111559696183819298513404064964764989322747380331696791867519982051605791248882885366524209802054710598555765955391852462439633943982981048910964043256256564325229426294671964554206474708341465373894148940727151214194139689084792219755509762230005111626849042747985158869367097312254406872850034913571110130728143964634865712772672734643550948438362346301458349337299157707730079513372432030621197588674055653062530555996149196609743532687216170","z":"93778352699867021765619934165008799881295978069847499844811661370915991426435091458883298643522917689224515675936514800886287234447829316238116204785086054074594105374642877677502098222139574702958647973238445636383103196939272529167319080485405444684105230018057567442014849977335578272510110388159541351950630632010401218865343115412536118951874784043891497867312223383705938532897959202542308749874499372712180726213936148207403021990672310360925511919874541139607380140131763264502271640162160069355963958793061754524973340652754459071456588159316376436763397689565809809070208372943194355879720736551162651124637"}},"issuerId":"did:prism:604ba1764ab89993f9a74625cc4f3e04737919639293eb382cc7adc53767f550"}
        "#;

        let link_secret = "98091256227184211848484897435149267683653315476615122579613930359331194674114";

        let presentation_request = PresentationRequest::new(request_json.to_string()).unwrap();

        let credential = Credential::new(credential_json.to_string()).unwrap();

        let requested_attributes_map = presentation_request.get_requested_attributes();
        let requested_predicates_map = presentation_request.get_requested_predicates();

        let mut requested_attributes = Vec::new();
        requested_attributes_map.iter().for_each(|attribute| {
            println!("{:?}", attribute.0);
            requested_attributes.append(
                &mut vec![RequestedAttribute {
                    referent: attribute.0.to_string(),
                    revealed: false
                }]
            );
        });

        let mut requested_predicates = Vec::new();
        requested_predicates_map.iter().for_each(|attribute| {
            requested_predicates.append(
                &mut vec![RequestedPredicate {
                    referent: attribute.0.to_string()
                }]
            );
        });

        let attr_names = AttributeNames::from(vec!["name".to_string(), "surname".to_string()]);
        let schema_id = credential.get_schema_id().clone();
        let shecme = Schema {
            name: "automation-anoncred".to_string(),
            version: "2.0.0".to_string(),
            attr_names: attr_names,
            issuer_id: IssuerId("did:prism:604ba1764ab89993f9a74625cc4f3e04737919639293eb382cc7adc53767f550".to_string()),
        };

        let mut shecme_map = HashMap::new();
        shecme_map.insert(schema_id, shecme);

        let credential_definition = CredentialDefinition::new(credential_definition_json.to_string()).unwrap();

        let mut credential_def = HashMap::new();
        credential_def.insert(credential.get_cred_def_id().clone(), credential_definition.into());

        let credential_requests = CredentialRequests {
            credential: credential.into(),
            requested_attribute: requested_attributes,
            requested_predicate: requested_predicates
        };

        let link_secret = LinkSecret::new_from_value(link_secret.to_string()).unwrap();

        let mut x = Vec::new();
        x.append(&mut vec![credential_requests]);

        let value = Prover::new().create_presentation(
            presentation_request.into(),
            x,
            None,
            link_secret.into(),
            shecme_map,
            credential_def
        ).unwrap();
        println!("{:?}", value.get_json());
    }
}
